import json
from datetime import datetime

from dateutil import parser as date_parser
from dateutil.relativedelta import relativedelta
import requests


class GoogleFinanceClient(object):
    CACHE_KEY = 'google_finance_tickers'
    # Duration, in seconds, between requests to avoid being banned or over-requesting
    API_REQUESTS_LIMIT = 30000
    MARKET_HOURS = (10, 18)
    MARKET_DAYS = (0, 1, 2, 3, 4)  # Monday is 0
    API_DELAY = 15 * 60  # duration in seconds
    URL = 'http://finance.google.com/finance/info?client={client}&q={q}'

    @classmethod
    def get_stock(cls, tickers=None, client='ig'):
        if tickers is None:
            return None

        if not isinstance(tickers, list):
            tickers = [tickers]

        return cls._request(client=client, tickers=tickers)

    @classmethod
    def _request(cls, client, tickers):
        params = {'client': client,
                  'q': ','.join(tickers),
                  }

        url = cls.URL.format(**params)
        response = requests.get(url, timeout=3)
        return cls.parse_response(response)

    @classmethod
    def parse_response(cls, response):
        if response.status_code != 200:
            return None

        stocks = {}
        all_data = json.loads(response.content.strip().replace('//', ''))
        for data in all_data:
            stocks[data['t']] = cls.parse_stock(data)
        return stocks

    @classmethod
    def parse_stock(cls, data):
        stock = {'c': float(data['c']),
                 'c_fix': float(data['c_fix']),
                 'cp': float(data['cp']),
                 'cp_fix': float(data['cp_fix']),
                 'l_fix': float(data['l_fix']),
                 'pcls_fix': float(data['pcls_fix']),
                 'id': data['id'],
                 'ccol': data['ccol'],
                 'e': data['e'],
                 't': data['t'],
                 's': data['s'],
                 'l_cur': data['l_cur'],
                 'lt': date_parser.parse(data['lt']),  # u'Aug 22, 2:12PM GMT-3'
                 'lt_dts': date_parser.parse(data['lt_dts']),  # u'2016-08-22T14:12:01Z'
                 'ltt': date_parser.parse(data['ltt'])  # u'2:12PM GMT-3'
                 }
        return stock

    @classmethod
    def calculate_cooldown(cls):
        time_to_open = cls.time_to_open_market()

        if time_to_open is None:  # fast
            return cls.minimum_cooldown()
        else:  # slow
            return time_to_open.total_seconds()

    @classmethod
    def minimum_cooldown(cls):
        duration_hours = cls.MARKET_HOURS[1] - cls.MARKET_DAYS[0]
        hourly = cls.API_REQUESTS_LIMIT / float(duration_hours)
        if hourly <= 1:
            return int(1 / hourly) * 60 * 60  # hours to seconds

        minutely = cls.API_REQUESTS_LIMIT / float(24 * 60)
        if minutely <= 1:
            return int(1 / minutely) * 60  # minutes to seconds

        secondly = cls.API_REQUESTS_LIMIT / float(24 * 60 * 60)
        if secondly <= 1:
            return int(1 / secondly)
        else:
            return secondly

    @classmethod
    def time_to_open_market(cls):
        now = datetime.now()
        if now.weekday() in cls.MARKET_DAYS:
            if now.hour < cls.MARKET_HOURS[0]:  # about to open
                opening_time = now + relativedelta(hour=cls.MARKET_HOURS[0], minute=0, second=0) + relativedelta(
                    seconds=cls.API_DELAY)
            elif now.hour > cls.MARKET_HOURS[1]:  # opens tomorrow
                next_weekday_candidates = [w for w in cls.MARKET_DAYS if w > now.weekday()]
                next_weekday = min(cls.MARKET_DAYS) if not next_weekday_candidates else next_weekday_candidates[0]

                opening_time = now + relativedelta(days=+1, hour=cls.MARKET_HOURS[0], minute=0, second=0,
                                                   weekday=next_weekday) + relativedelta(seconds=cls.API_DELAY)
            else:  # opened
                return None
        else:
            next_weekday_candidates = [w for w in cls.MARKET_DAYS if w > now.weekday()]
            next_weekday = min(cls.MARKET_DAYS) if not next_weekday_candidates else next_weekday_candidates[0]

            opening_time = now + relativedelta(days=+1, hour=cls.MARKET_HOURS[0], minute=0, second=0,
                                               weekday=next_weekday) + relativedelta(seconds=cls.API_DELAY)

        return opening_time - now
